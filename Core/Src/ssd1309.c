#include "ssd1309.h"
#include <string.h>

extern SPI_HandleTypeDef hspi2;

/* Шрифт 5x7: Байт = Вертикальная колонка (LSB вверху) */
static const uint8_t Font5x7[] = {
    0x00,0x00,0x00,0x00,0x00, 0x00,0x00,0x5F,0x00,0x00, 0x00,0x07,0x00,0x07,0x00, 0x14,0x7F,0x14,0x7F,0x14,
    0x24,0x2A,0x7F,0x2A,0x12, 0x23,0x13,0x08,0x64,0x62, 0x36,0x49,0x55,0x22,0x50, 0x00,0x05,0x03,0x00,0x00,
    0x00,0x1C,0x22,0x41,0x00, 0x00,0x41,0x22,0x1C,0x00, 0x08,0x2A,0x1C,0x2A,0x08, 0x08,0x08,0x3E,0x08,0x08,
    0x00,0x50,0x30,0x00,0x00, 0x08,0x08,0x08,0x08,0x08, 0x00,0x60,0x60,0x00,0x00, 0x20,0x10,0x08,0x04,0x02,
    0x3E,0x51,0x49,0x45,0x3E, 0x00,0x42,0x7F,0x40,0x00, 0x42,0x61,0x51,0x49,0x46, 0x21,0x41,0x45,0x4B,0x31,
    0x18,0x14,0x12,0x7F,0x10, 0x27,0x45,0x45,0x45,0x39, 0x3C,0x4A,0x49,0x49,0x30, 0x01,0x71,0x09,0x05,0x03,
    0x36,0x49,0x49,0x49,0x36, 0x06,0x49,0x49,0x29,0x1E, 0x00,0x36,0x36,0x00,0x00, 0x00,0x56,0x36,0x00,0x00,
    0x08,0x14,0x22,0x41,0x00, 0x14,0x14,0x14,0x14,0x14, 0x00,0x41,0x22,0x14,0x08, 0x02,0x01,0x51,0x09,0x06,
    0x32,0x49,0x79,0x41,0x3E, 0x7E,0x11,0x11,0x11,0x7E, 0x7F,0x49,0x49,0x49,0x36, 0x3E,0x41,0x41,0x41,0x22,
    0x7F,0x41,0x41,0x22,0x1C, 0x7F,0x49,0x49,0x49,0x41, 0x7F,0x09,0x09,0x01,0x01, 0x3E,0x41,0x49,0x49,0x7A,
    0x7F,0x08,0x08,0x08,0x7F, 0x00,0x41,0x7F,0x41,0x00, 0x20,0x40,0x41,0x3F,0x01, 0x7F,0x08,0x14,0x22,0x41,
    0x7F,0x40,0x40,0x40,0x40, 0x7F,0x02,0x0C,0x02,0x7F, 0x7F,0x04,0x08,0x10,0x7F, 0x3E,0x41,0x41,0x41,0x3E,
    0x7F,0x09,0x09,0x09,0x06, 0x3E,0x41,0x51,0x21,0x5E, 0x7F,0x09,0x19,0x29,0x46, 0x46,0x49,0x49,0x49,0x31,
    0x01,0x01,0x7F,0x01,0x01, 0x3F,0x40,0x40,0x40,0x3F, 0x1F,0x20,0x40,0x20,0x1F, 0x3F,0x40,0x38,0x40,0x3F,
    0x63,0x14,0x08,0x14,0x63, 0x07,0x08,0x70,0x08,0x07, 0x61,0x51,0x49,0x45,0x43, 0x00,0x7F,0x41,0x41,0x00,
    0x02,0x04,0x08,0x10,0x20, 0x00,0x41,0x41,0x7F,0x00, 0x04,0x02,0x01,0x02,0x04, 0x40,0x40,0x40,0x40,0x40,
    0x00,0x01,0x02,0x04,0x00, 0x20,0x54,0x54,0x54,0x78, 0x7F,0x48,0x44,0x44,0x38, 0x38,0x44,0x44,0x44,0x20,
    0x38,0x44,0x44,0x48,0x7F, 0x38,0x54,0x54,0x54,0x18, 0x08,0x7E,0x09,0x01,0x02, 0x0C,0x52,0x52,0x52,0x3E,
    0x7F,0x08,0x04,0x04,0x78, 0x00,0x44,0x7D,0x40,0x00, 0x20,0x40,0x44,0x3D,0x00, 0x7F,0x10,0x28,0x44,0x00,
    0x00,0x41,0x7F,0x40,0x00, 0x7C,0x04,0x18,0x04,0x7C, 0x7C,0x08,0x04,0x04,0x78, 0x38,0x44,0x44,0x44,0x38,
    0x7C,0x14,0x14,0x14,0x08, 0x08,14,0x14,0x18,0x7C, 0x7C,0x08,0x04,0x04,0x08, 0x48,0x54,0x54,0x54,0x20,
    0x04,0x3F,0x44,0x40,0x20, 0x3C,0x40,0x40,0x20,0x7C, 0x1C,0x20,0x40,0x20,0x1C, 0x3C,0x40,0x30,0x40,0x3C,
    0x44,0x28,0x10,0x28,0x44, 0x0C,0x50,0x50,0x50,0x3C, 0x44,0x64,0x54,0x4C,0x44, 0x00,0x08,0x36,0x41,0x00,
    0x00,0x00,0x7F,0x00,0x00, 0x00,0x41,0x36,0x08,0x00, 0x08,0x08,0x2A,0x1C,0x08, 0x08,0x1C,0x2A,0x08,0x08
};

/* Выравнивание буфера по 32 байта для корректной работы кэша L1 на H7 */
__attribute__((aligned(32))) static uint8_t SSD1309_Buffer[SSD1309_WIDTH * SSD1309_HEIGHT / 8];

static uint8_t CurrentX = 0, CurrentY = 0;

/**
 * Отправка одиночной команды дисплею
 */
static void SSD1309_WriteCommand(uint8_t byte) {
    HAL_GPIO_WritePin(SPI2_DC_GPIO_Port, SPI2_DC_Pin, GPIO_PIN_RESET);
    HAL_GPIO_WritePin(SPI2_CS_GPIO_Port, SPI2_CS_Pin, GPIO_PIN_RESET);
    HAL_SPI_Transmit(&hspi2, &byte, 1, HAL_MAX_DELAY);
    HAL_GPIO_WritePin(SPI2_CS_GPIO_Port, SPI2_CS_Pin, GPIO_PIN_SET);
}

void SSD1309_Init(void) {
    // Аппаратный сброс (используем метки из main.h)
    HAL_GPIO_WritePin(SPI2_RST_GPIO_Port, SPI2_RST_Pin, GPIO_PIN_RESET);
    HAL_Delay(50);
    HAL_GPIO_WritePin(SPI2_RST_GPIO_Port, SPI2_RST_Pin, GPIO_PIN_SET);
    HAL_Delay(50);

    SSD1309_WriteCommand(0xAE); // Display Off
    SSD1309_WriteCommand(0x20); // Set Memory Addressing Mode
    SSD1309_WriteCommand(0x00); // Horizontal addressing mode
    SSD1309_WriteCommand(0xA1); // Set Segment Re-map (X-flip)
    SSD1309_WriteCommand(0xC8); // Set COM Output Scan Direction (Y-flip)
    SSD1309_WriteCommand(0xA8); // Set Multiplex Ratio
    SSD1309_WriteCommand(0x3F);
    SSD1309_WriteCommand(0xD3); // Set Display Offset
    SSD1309_WriteCommand(0x00);
    SSD1309_WriteCommand(0xD5); // Set Display Clock Divide Ratio
    SSD1309_WriteCommand(0x80);
    SSD1309_WriteCommand(0xD9); // Set Pre-charge Period
    SSD1309_WriteCommand(0x22);
    SSD1309_WriteCommand(0xDA); // Set COM Pins Hardware Configuration
    SSD1309_WriteCommand(0x12);
    SSD1309_WriteCommand(0xDB); // Set VCOMH Deselect Level
    SSD1309_WriteCommand(0x20);
    SSD1309_WriteCommand(0x8D); // Charge Pump Settings
    SSD1309_WriteCommand(0x14);
    SSD1309_WriteCommand(0xAF); // Display On

    SSD1309_Fill(0);
    SSD1309_UpdateScreen();
}

void SSD1309_Fill(uint8_t color) {
    memset(SSD1309_Buffer, (color ? 0xFF : 0x00), sizeof(SSD1309_Buffer));
}

/**
 * Обновление экрана через DMA.
 * Использует горизонтальную адресацию для отправки всего кадра одним пакетом.
 */
void SSD1309_UpdateScreen(void) {
    // 1. Устанавливаем окно отрисовки на весь экран
    SSD1309_WriteCommand(0x21); // Column address range
    SSD1309_WriteCommand(0);    // Start
    SSD1309_WriteCommand(127);  // End

    SSD1309_WriteCommand(0x22); // Page address range
    SSD1309_WriteCommand(0);    // Start
    SSD1309_WriteCommand(7);    // End

    // 2. Подготовка к передаче данных
    HAL_GPIO_WritePin(SPI2_DC_GPIO_Port, SPI2_DC_Pin, GPIO_PIN_SET);
    HAL_GPIO_WritePin(SPI2_CS_GPIO_Port, SPI2_CS_Pin, GPIO_PIN_RESET);

    // КРИТИЧНО ДЛЯ H7: Синхронизация Кэша с RAM перед тем как DMA заберет данные
    SCB_CleanDCache_by_Addr((uint32_t*)SSD1309_Buffer, sizeof(SSD1309_Buffer));

    // 3. Запуск передачи всего буфера по DMA
    HAL_SPI_Transmit_DMA(&hspi2, SSD1309_Buffer, sizeof(SSD1309_Buffer));

    // ПРИМЕЧАНИЕ: Мы НЕ ждем здесь окончания (while), чтобы CPU мог делать другие задачи.
    // CS поднимется автоматически в коллбэке завершения DMA, если вы его настроите,
    // или можно оставить CS прижатым, так как на шине только одно устройство.
}

void SSD1309_SetCursor(uint8_t x, uint8_t y) {
    CurrentX = x;
    CurrentY = y;
}

void SSD1309_WriteChar(char ch, uint8_t color) {
    if (ch < 32 || ch > 126) return;

    for (uint8_t i = 0; i < 5; i++) {
        uint8_t b = Font5x7[(ch - 32) * 5 + i];
        for (uint8_t j = 0; j < 8; j++) {
            if ((b >> j) & 0x01) {
                uint8_t x = CurrentX + i;
                uint8_t y = CurrentY + j;

                if (x < SSD1309_WIDTH && y < SSD1309_HEIGHT) {
                    if (color)
                        SSD1309_Buffer[x + (y / 8) * SSD1309_WIDTH] |= (1 << (y % 8));
                    else
                        SSD1309_Buffer[x + (y / 8) * SSD1309_WIDTH] &= ~(1 << (y % 8));
                }
            }
        }
    }
    CurrentX += 6;
}

void SSD1309_WriteString(const char *str, uint8_t color) {
    while (*str) {
        SSD1309_WriteChar(*str++, color);
    }
}
